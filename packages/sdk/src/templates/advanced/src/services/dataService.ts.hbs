import { createClient } from '@supabase/supabase-js';
import type { DataItem } from '../types';

// Configuração do Supabase
const supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'http://localhost:3030';
const supabaseKey = process.env.REACT_APP_SUPABASE_ANON_KEY || 'mock-key';

// Criar cliente Supabase
const supabase = createClient(supabaseUrl, supabaseKey);

// Nome da tabela (será substituído pelo nome do módulo)
const TABLE_NAME = '{{name}}_data';

export const dataService = {
  /**
   * Buscar todos os itens do usuário atual
   */
  async getAll(): Promise<DataItem[]> {
    try {
      const { data, error } = await supabase
        .from(TABLE_NAME)
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        throw new Error(`Erro ao buscar dados: ${error.message}`);
      }

      return data || [];
    } catch (error) {
      console.error('Erro no dataService.getAll:', error);
      throw error;
    }
  },

  /**
   * Buscar item por ID
   */
  async getById(id: string): Promise<DataItem | null> {
    try {
      const { data, error } = await supabase
        .from(TABLE_NAME)
        .select('*')
        .eq('id', id)
        .single();

      if (error) {
        throw new Error(`Erro ao buscar item: ${error.message}`);
      }

      return data;
    } catch (error) {
      console.error('Erro no dataService.getById:', error);
      throw error;
    }
  },

  /**
   * Criar novo item
   */
  async create(item: Partial<DataItem>): Promise<DataItem> {
    try {
      const { data, error } = await supabase
        .from(TABLE_NAME)
        .insert([{
          name: item.name,
          description: item.description,
          status: item.status || 'active',
          created_by: item.created_by
        }])
        .select('*')
        .single();

      if (error) {
        throw new Error(`Erro ao criar item: ${error.message}`);
      }

      return data;
    } catch (error) {
      console.error('Erro no dataService.create:', error);
      throw error;
    }
  },

  /**
   * Atualizar item existente
   */
  async update(id: string, updates: Partial<DataItem>): Promise<DataItem> {
    try {
      const { data, error } = await supabase
        .from(TABLE_NAME)
        .update({
          name: updates.name,
          description: updates.description,
          status: updates.status,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select('*')
        .single();

      if (error) {
        throw new Error(`Erro ao atualizar item: ${error.message}`);
      }

      return data;
    } catch (error) {
      console.error('Erro no dataService.update:', error);
      throw error;
    }
  },

  /**
   * Excluir item
   */
  async delete(id: string): Promise<void> {
    try {
      const { error } = await supabase
        .from(TABLE_NAME)
        .delete()
        .eq('id', id);

      if (error) {
        throw new Error(`Erro ao excluir item: ${error.message}`);
      }
    } catch (error) {
      console.error('Erro no dataService.delete:', error);
      throw error;
    }
  },

  /**
   * Pesquisar itens por termo
   */
  async search(searchTerm: string): Promise<DataItem[]> {
    try {
      const { data, error } = await supabase
        .from(TABLE_NAME)
        .select('*')
        .or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`)
        .order('created_at', { ascending: false });

      if (error) {
        throw new Error(`Erro na pesquisa: ${error.message}`);
      }

      return data || [];
    } catch (error) {
      console.error('Erro no dataService.search:', error);
      throw error;
    }
  },

  /**
   * Filtrar itens por status
   */
  async getByStatus(status: string): Promise<DataItem[]> {
    try {
      const { data, error } = await supabase
        .from(TABLE_NAME)
        .select('*')
        .eq('status', status)
        .order('created_at', { ascending: false });

      if (error) {
        throw new Error(`Erro ao filtrar por status: ${error.message}`);
      }

      return data || [];
    } catch (error) {
      console.error('Erro no dataService.getByStatus:', error);
      throw error;
    }
  },

  /**
   * Contar itens por status
   */
  async getStatusCounts(): Promise<Record<string, number>> {
    try {
      const { data, error } = await supabase
        .from(TABLE_NAME)
        .select('status');

      if (error) {
        throw new Error(`Erro ao contar por status: ${error.message}`);
      }

      const counts: Record<string, number> = {};
      data?.forEach(item => {
        counts[item.status] = (counts[item.status] || 0) + 1;
      });

      return counts;
    } catch (error) {
      console.error('Erro no dataService.getStatusCounts:', error);
      throw error;
    }
  },

  /**
   * Verificar conexão com o banco
   */
  async checkConnection(): Promise<boolean> {
    try {
      const { error } = await supabase
        .from(TABLE_NAME)
        .select('count(*)', { count: 'exact', head: true });

      return !error;
    } catch (error) {
      console.error('Erro na verificação de conexão:', error);
      return false;
    }
  }
};